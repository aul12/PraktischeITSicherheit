\section{How does Intel SGX work}

\begin{frame}
    \frametitle{Overview}
    \begin{itemize}[<+->]
        \item Application is split into a secure part and a non-secure part
        \begin{itemize}
            \item Trusted functions processing secrets (e.g. passwords, encryption keys)
            \item Untrusted functions for non-critical computations / procedures
        \end{itemize}
        \item Trusted functions are handled by so called ``enclaves``
        \item Enclave is launched by the application
        \item Enclave code is called by the application through enclave entry point
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Overview}
    \begin{itemize}[<+->]
        \item Enclaves can be seen as shared objects (.so on Unix, .dll on Windows) which provide trusted functions
        \item Trusted functions should only handle security critical procedures (e.g. password reads)
        \item Enclave memory can only be read by trusted functions
    \end{itemize}
    $ $ \newline
    \centering
    \incfig[0.4\textwidth]{Enclave}
\end{frame}

%Quellen unten anpassen
\incfuck[0.8\textwidth]{AppOverview}{1}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{2}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{3}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{4}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{5}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{6}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{7}{{}}{Overview}
\incfuck[0.8\textwidth]{AppOverview}{8}{{}}{Overview}


\begin{frame}
    \frametitle{Implementation: SGX Memory Layout}
    \begin{itemize}[<+->]
        \item Code and data of enclaves is stored in a special memory area, called Enclave Page Cache (EPC)
        \item Each EPC-page is owned by exactly one enclave
        \item Enclave Page Cache Map (EPCM) determines mapping from enclave to EPC-pages
        \item EPCM also records for each EPC-page the corresponding virtual address
        \item EPC and EPCM reside in reserved part of system memory (Processor Reserved Memory (PRM))
        \item CPU denies direct access to PRM even by OS, BIOS, etc \dots
        \item PRM is encrypted on hardware level
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Implementation: SGX Memory Layout}
    \centering
    \incfig[0.6\textwidth]{MemoryLayout}
\end{frame}

\begin{frame}
    \frametitle{Implementation: Enclave Mode}
    \begin{itemize}[<+->]
        \item SGX adds a new CPU mode i.e. the ``Enclave Mode``
        \begin{itemize}
            \item Standard application code runs in ``untrusted mode``
            \item Enclave code (i.e. trusted functions) run in enclave mode
        \end{itemize}
        \item Code running in untrusted mode cannot access EPC-pages
        \item Code running in enclave mode can access untrusted memory / code
        \item Modes can be switched by special CPU-instructions
    \end{itemize}
    $ $ \newline
    \centering
    \visible<6>{
        \begin{tabular}{l | l}
        Standard CPU-modes & SGX-modes \\
        \hline
        User mode & Untrusted mode \\
        Kernel mode & Enclave mode \\
    \end{tabular}}
\end{frame}

\begin{frame}
    \frametitle{Implementation: Page Mapping and Page Checks}
    \begin{itemize}[<+->]
        \item Address translation and page mapping is delegated to the system software \newline
              $\Rightarrow$ small overhead, standard address translation is used
        \item Since the OS is not trusted, additional checks have to be performed by the CPU
        \item Intel SGX ensures that: 
            \begin{itemize}
                \item virtual addresses pointing to enclave code or data are mapped to EPC-pages
                \item EPC-pages can only be mapped to one specific virtual address
                \item EPC-pages are allocated to exactly one enclave (by checking the EPCM)
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Extended Page Check}
    \begin{figure}
        \centering
        \incfig[0.75\textwidth]{PageCheck}
        \caption*{Source: \url{https://blog.quarkslab.com/overview-of-intel-sgx-part-1-sgx-internals.html}}
    \end{figure}
\end{frame}

\begin{frame}
    \frametitle{Implementation: Special Instructions}
    \begin{itemize}[<+->]
        \item SGX introduces new CPU instructions which are used to:
        \begin{itemize}
            \item Switch between untrusted mode and enclave mode (EENTER, EEXIT)
            \item Create and tear down enclaves (ECREATE, EREMOVE, EINIT, EADD)
            \item Compute cryptographic signatures for attestation process (EGETKEY, EREPORT, EEXTEND)
        \end{itemize}
        \item Instructions are implemented in micro code
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Implementation}
    \begin{itemize}[<+->]
        \item Intel SGX defines 18 new instructions to handle enclaves in hardware
        \item Intructions to load enclaves are called through systemcalls, e.g ECREATE
        \item Instructions to communicate with the enclave can be called by user, e.g. EENTRY, EEXIT
        \item CPU has an extra enclave Mode to call some of these instructions
        \item Enclave mode needs a context switch and is for the whole enclave handling and enclave code execution
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Enclave Page Cache (EPC)}
    \begin{itemize}[<+->]
        \item Code and data of the enclave is stored in a special memory area, called EPC
        \item This area is encrypted by using the Memory Encryption Engine (MEE)
        \item MEE is an extra new and dedicated circuit for Intel SGX
        \item Only enclave can read from its own EPC
        \item EPC page content is only decrypted inside the CPU
        \item Keys for de-/encrypting are generated at boot-time and are stored inside the CPU
        \item Enclaves can access their application memory, but not the other way arround
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Page Check}
    \begin{itemize}[<+->]
        \item Page check is extended to prevent external access to EPC
        \item The Enclave Page Cache Metadata (EPCM) is stored inside the EPC
        \begin{itemize}
            \item EPCM is a map from enclave to pages in the EPC
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Page Check}
    \begin{figure}
        \centering
        \incfig[0.75\textwidth]{PageCheck}
        \caption*{Source: \url{https://blog.quarkslab.com/overview-of-intel-sgx-part-1-sgx-internals.html}}
    \end{figure}
\end{frame}

\begin{frame}
    \frametitle{Application procedure}

\end{frame}

\begin{frame}
    \frametitle{Application procedure}
    \begin{columns}
        \begin{column}{0.3\textwidth}
           \begin{enumerate}[<+->]
               \item EENTRY instruction is executed to enter enclave
               \item The application context is saved
               \item The processor is put in enclave mode
               \item EEXIT instruction is executed to exit enclave
               \item The processor is put in normal mode
           \end{enumerate}
        \end{column}
        \begin{column}{0.7\textwidth}
            \begin{center}
                \includegraphics[scale=0.35]{Images/procedure.png}
            \end{center}
        \end{column}
        \end{columns}
\end{frame}

\begin{frame}
    \frametitle{Attestation}
    \begin{itemize}[<+->]
        \item Attestation is to verify the integrity of an enclave
        \item Through attestation you can verify, that you can trust the code inside the enclave
        \item For attestation a report will be generated, which contains multiple information
        \item Report is signed with an key from the second enclave, which is public because of an asynchronous key exchange
        \item Attestation is for a secure communication between 2 enclaves on same CPU or via remote 
        \item For remote attestation an quoting enclave is needed as third-party
        \item Quoting enclaves signs local reports for remote attestation
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Local Attestation}
    \begin{columns}
        \begin{column}{0.4\textwidth}
            \begin{enumerate}[<+->]
                \item Enclave A receives the enclave Measure (MRENCLAVE) from enclave B via an established channel
                \item Enclave A generates the report and signed it up with the MRENCLAVE from B and send the report back
                \item Enclave B decrypts the report and can verify, enclave A is on the same platform and trustable
            \end{enumerate}
        \end{column}
        \begin{column}{0.6\textwidth}
            \includegraphics[scale=0.45]{Images/local_attestation.png}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}
    \frametitle{Remote Attestation}
    \begin{columns}
        \begin{column}{0.4\textwidth}
            \begin{enumerate}[<+->]
                \item Application receives an attestion request from challenger
                \item Local attestation is requested from application
                \item Application receives local attestation
                \item Local attestation is send to quoting enclave
                \item quoting enclave converts local report to remote report (Quote) and sends back
                \item challenger receives quote
                \item Attestation verification service verifies quote
            \end{enumerate}
        \end{column}
        \begin{column}{0.6\textwidth}
            \includegraphics[scale=0.4]{Images/remote_attestation.png}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}
    \frametitle{Sealing}
    \begin{itemize}[<+->]
        \item Process of encrypting enclave secrets for persistent sorage is calles sealing
        \item Different ways of sealing
        \item Enclave retrieves the seal Key using the EGETKEY instruction, which returns a cryptographical key
        \item Key is used to encrypt and ensure data integrity
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Sealing - Different ways}
    \begin{itemize}[<+->]
        \item Enclave Identity
        \begin{itemize}[<+->]
            \item Two distinct enclaves have different keys
            \item Sealed data will not be available to different versions of the same enclave
            \item Sealed data will only be available to identical enclave instantiations
        \end{itemize}
        \item Signer Identity
        \begin{itemize}[<+->]
            \item Two distinct enclaves have different keys
            \item Two versions of an enclave share the same key
            \item multiple enclaves which are using the same key can all read each others data
        \end{itemize}
        \item Security Version Number (SVN)
        \begin{itemize}[<+->]
            \item SVN is a counter which is incremented after each update
            \item Older versions of an enclave are not available to read data from a newer version
            \item keys are derived that an enclave can retrieve the keys corresponding to current or older security level
        \end{itemize}
    \end{itemize}

    

\end{frame}

